#!/usr/bin/env python# -*- coding: UTF-8 -*-import refrom datetime import datetime, date, timedeltafrom eve import Evefrom eve.io.mongo import Validatorfrom eve.auth import BasicAuthfrom eve.utils import configdef datestring_add(datestring, days):	''' Returns the date specified as string in ISO format with given	number of days added.	'''	return (datetime.strptime(datestring, '%Y-%m-%d') + timedelta(days=days)).date().isoformat()def post_all_methods_callback(resource, request, payload):	''' A method called before sending a response to any method.		Renames all `_id` fields in the response to `id`.	'''	data = payload.get_data()	if request.headers.get('Accept') == 'application/xml':		data = data.replace(b'<_id', b'<id').replace(b'</_id', b'</id')	else:		data = data.replace(b'"_id"', b'"id"')	payload.set_data(data)def _get_effective_date(document):	''' Gets `effective_date` field and removes it from the document	or returns current date if there is not such field or it is empty.	'''	effective_date = document.get('effective_date') or date.today().isoformat()	if 'effective_date' in document:		del document['effective_date']	return effective_datedef _build_change(key, original, effective_date):	''' Creates a change to include into the list of changes holding	original value of the key property.	'''	change = {		'property': key,		'value': original.get(key),		'end_date': datestring_add(effective_date, -1),	}	# if there are older values of this property already present in `changes` then	# validity of the current value will start immediately after the most recent one	former_end_dates = [ch['end_date'] for ch in original.get('changes', []) if ch['property'] == key]	if former_end_dates:		change['start_date'] = datestring_add(max(former_end_dates), 1)			return changedef before_update_callback(resource, original, updates):	'''Adds all changes in updated tracked properties to the list	in `changed` property of the resource.	'''	effective_date = _get_effective_date(updates)		changes = []	for key in config.DOMAIN[resource].get('track_changes', []):		if key in updates and updates[key] != original.get(key):			change = _build_change(key, original, effective_date)			changes.append(change)	if changes or 'changes' in updates:		updates['changes'] = changes + updates.get('changes', []) + original.get('changes', [])def before_replace_callback(resource, original, document):	'''Adds all changes in all tracked properties to the list	in `changed` property of the resource.	'''	effective_date = _get_effective_date(document)		changes = []	for key in config.DOMAIN[resource].get('track_changes', []):		if document.get(key) != original.get(key):			change = _build_change(key, original, effective_date)			changes.append(change)	if changes or 'changes' in document or 'changes' in original:		document['changes'] = changes + document.get('changes', []) + original.get('changes', [])		class VpapiValidator(Validator):	''' Additional validations in the schema.	'''	def _validate_format(self, format, field, value):		''' Validates for custom rule `format`.		'''		if format not in ['partialdate', 'email', 'url']:			self._error(field, 'Unknown format "{0}"'.format(format))		if format == 'partialdate' and not re.match(r'^[0-9]{4}(-[0-9]{2}){0,2}$', value) \				or format == 'email' and not re.match(r'[^@]+@[^@]+\.[^@]+', value):			self._error(field, "Value '{0}' does not satisfy format '{1}'".format(value, format))		# no validation for URLs because virtually everything is a valid URL according to RFC 3986	def _validate_disjoint(self, disjoint, field, value):		''' Validates for custom rule `disjoint` that is similar to the		`unique` rule, but instead of comparing values as a whole checks for		no common element in the lists.		Applicable only to fields with type `list`.		'''		if not isinstance(value, list):			self._error(field, '`disjoint` rule allowed only for `list` fields')		if disjoint:			query = {}			if self._id:				try:					query[config.ID_FIELD] = {'$ne': ObjectId(self._id)}				except:					query[config.ID_FIELD] = {'$ne': self._id}			for element in value:				if isinstance(element, dict):					query[field] = { '$elemMatch': element }				else:					query[field] = element				if app.data.find_one(self.resource, **query):					self._error(field, 'value `%s` for field `%s` contains a common element with an existing value' % (value, field))					break	def _validate_unique_elements(self, unique_elements, field, value):		''' Validates for custom rule `unique_elements` that checks all values		are unique within the list.		Applicable only to fields with type `list`.		'''		if not isinstance(value, list):			self._error(field, '`unique_elements` rule allowed only for `list` fields')		if unique_elements:			if self._id:				try:					query = {config.ID_FIELD: ObjectId(self._id)}				except:					query = {config.ID_FIELD: self._id}				value_in_db =  app.data.find_one(self.resource, **query)				if 'field' in value_in_db:					value.extend(value_in_db['field'])			if value:				if isinstance(value[0], dict):					uniqified = set(frozenset(element.items()) for element in value)				else:					uniqified = set(frozenset(element) for element in value)				if len(uniqified) < len(value):					self._error(field, 'elements within the list `%s` are not unique' % (value))class VpapiBasicAuth(BasicAuth):	'''Authentication used for write acces to the API.	'''	def check_auth(self, username, password, allowed_roles, resource, method):		return (username, password) in config.AUTHORIZED_USERSapp = Eve(validator=VpapiValidator, auth=VpapiBasicAuth)# responses of all methods will be adjusted (_id fields renamed to id)app.on_post_GET += post_all_methods_callbackapp.on_post_POST += post_all_methods_callbackapp.on_post_PUT += post_all_methods_callbackapp.on_post_PATCH += post_all_methods_callbackapp.on_post_DELETE += post_all_methods_callback# changed values tracking on update and replace (PATCH, PUT)app.on_update += before_update_callbackapp.on_replace += before_replace_callbackif __name__ == '__main__':	app.run()